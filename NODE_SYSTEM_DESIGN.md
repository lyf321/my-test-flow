# 节点系统详细设计文档

## 📋 目录

1. [节点架构设计](#节点架构设计)
2. [节点复用机制](#节点复用机制)
3. [节点注册系统](#节点注册系统)
4. [节点配置系统](#节点配置系统)
5. [节点执行系统](#节点执行系统)
6. [节点扩展机制](#节点扩展机制)

---

## 节点架构设计

### 1.1 节点分层架构

#### 设计理念
采用**关注点分离**原则，将节点系统分为四个层次：

```
┌─────────────────────────────────────────────┐
│  应用层 (Application Layer)                 │
│  - 具体业务节点组件 (StartNode.vue等)        │
│  - 节点UI渲染和用户交互                      │
│  - 节点样式和动画                            │
└─────────────────────────────────────────────┘
                    ↓ 使用
┌─────────────────────────────────────────────┐
│  业务层 (Business Layer)                    │
│  - 节点定义注册表 (NodeRegistry)             │
│  - 节点元数据管理 (NodeMetadata)             │
│  - 节点配置Schema (NodeConfigSchema)         │
│  - 节点连接规则 (NodeConnectionRules)        │
└─────────────────────────────────────────────┘
                    ↓ 依赖
┌─────────────────────────────────────────────┐
│  抽象层 (Abstraction Layer)                 │
│  - 节点基础接口 (INode)                      │
│  - 节点执行器接口 (INodeExecutor)            │
│  - 节点验证器接口 (INodeValidator)           │
│  - 节点工厂接口 (INodeFactory)               │
└─────────────────────────────────────────────┘
                    ↓ 实现
┌─────────────────────────────────────────────┐
│  基础层 (Core Layer)                        │
│  - 节点数据模型 (NodeModel)                  │
│  - 节点状态管理 (NodeState)                  │
│  - 节点事件系统 (NodeEvents)                │
│  - 节点工具函数 (NodeUtils)                  │
└─────────────────────────────────────────────┘
```

### 1.2 节点组件结构

#### 节点组件组成
每个节点由以下部分组成：

1. **UI组件** (Vue Component)
   - 节点外观渲染
   - 用户交互处理
   - 状态可视化

2. **元数据定义** (Node Metadata)
   - 节点类型信息
   - 连接规则定义
   - 配置Schema定义

3. **执行器** (Node Executor)
   - 节点执行逻辑
   - 数据处理逻辑
   - 错误处理逻辑

4. **验证器** (Node Validator)
   - 配置验证
   - 连接验证
   - 数据验证

### 1.3 节点数据模型

#### 节点数据结构
```
Node {
  // 基础信息
  id: string                    // 唯一标识
  type: string                  // 节点类型
  position: { x, y }           // 位置坐标
  
  // 数据
  data: {
    title?: string              // 显示标题
    config?: Record<string, any> // 配置数据
    inputs?: Record<string, any>  // 输入数据
    outputs?: Record<string, any> // 输出数据
    [key: string]: any          // 扩展数据
  }
  
  // 样式
  style?: {
    width?: number
    height?: number
    [key: string]: any
  }
  
  // 状态
  selected?: boolean
  dragging?: boolean
  executing?: boolean
  error?: boolean
}
```

---

## 节点复用机制

### 2.1 复用策略

#### 策略一：基础组件复用
**设计思路**：
- 创建通用的 `BaseNode.vue` 组件
- 所有具体节点通过组合或继承使用基础组件
- 通过 props、slots、scoped slots 实现差异化

**优势**：
- 统一的节点外观和行为
- 减少重复代码
- 易于维护和更新

**实现方式**：
- 基础组件提供通用功能（选中、拖拽、连接点等）
- 具体节点通过插槽注入自定义内容
- 通过配置对象控制节点行为

#### 策略二：配置驱动渲染
**设计思路**：
- 节点外观和行为由配置对象决定
- 通过 JSON Schema 定义节点结构
- 运行时根据配置动态渲染节点

**优势**：
- 高度灵活，无需修改代码即可调整节点
- 支持动态节点类型
- 便于模板化和序列化

**实现方式**：
- 定义节点配置Schema
- 根据Schema生成UI组件
- 配置变更时动态更新节点

#### 策略三：工厂模式创建
**设计思路**：
- 使用工厂函数创建节点实例
- 根据节点类型动态选择组件和配置
- 支持节点类型的动态注册

**优势**：
- 解耦节点创建逻辑
- 支持插件化扩展
- 便于测试和模拟

**实现方式**：
- 节点工厂根据类型查找注册表
- 获取节点定义和组件
- 创建并初始化节点实例

### 2.2 组件复用模式

#### 模式一：组合模式 (Composition)
```
BaseNode (基础组件)
  ├── NodeHeader (头部)
  ├── NodeBody (主体) ← 插槽注入
  │   └── StartNodeContent (具体内容)
  └── NodeFooter (底部)
```

**适用场景**：
- 节点结构相似，内容不同
- 需要统一的交互行为
- 需要统一的样式风格

#### 模式二：继承模式 (Inheritance)
```
BaseNode (基类)
  └── StartNode (继承)
      └── 重写特定方法
```

**适用场景**：
- 节点行为差异较大
- 需要完全自定义
- 性能要求高

#### 模式三：混入模式 (Mixin)
```
BaseNodeMixin (混入)
  └── StartNode (使用混入)
      └── 组合混入功能
```

**适用场景**：
- 需要共享部分功能
- 不想使用继承
- 需要灵活组合

### 2.3 节点配置复用

#### 配置层级
```
全局默认配置
    ↓ 继承
节点类型默认配置
    ↓ 继承
节点实例配置
    ↓ 覆盖
用户自定义配置
```

#### 配置合并策略
1. **深度合并**：递归合并对象属性
2. **数组替换**：数组类型直接替换
3. **函数合并**：函数类型组合执行

#### 配置模板
- **预设模板**：常用配置的预设值
- **用户模板**：用户保存的配置模板
- **模板应用**：一键应用配置模板

### 2.4 样式复用机制

#### 样式系统设计
1. **主题系统**
   - 定义统一的颜色、字体、间距
   - 支持主题切换
   - 支持自定义主题

2. **样式变量**
   - 使用CSS变量定义样式
   - 支持动态修改
   - 支持作用域隔离

3. **样式类库**
   - 提供常用样式类
   - 支持组合使用
   - 支持扩展

---

## 节点注册系统

### 3.1 注册表设计

#### 注册表结构
```
NodeRegistry {
  // 节点类型定义映射
  nodeDefinitions: Map<string, NodeDefinition>
  
  // 组件映射
  components: Map<string, Component>
  
  // 执行器映射
  executors: Map<string, NodeExecutor>
  
  // 验证器映射
  validators: Map<string, NodeValidator>
}
```

#### 节点定义结构
```
NodeDefinition {
  // 基本信息
  type: string                    // 节点类型ID
  name: string                    // 显示名称
  description: string            // 描述
  icon: string                    // 图标
  category: string                // 分类
  
  // UI相关
  component: Component | string   // 组件或组件路径
  defaultStyle: NodeStyle         // 默认样式
  defaultSize: { width, height }  // 默认尺寸
  
  // 连接规则
  connectionRules: {
    inputs: PortDefinition[]     // 输入端口定义
    outputs: PortDefinition[]    // 输出端口定义
    rules: ConnectionRule[]       // 连接规则
  }
  
  // 配置Schema
  configSchema: JSONSchema        // 配置Schema
  
  // 执行相关
  executor: NodeExecutor          // 执行器
  validator: NodeValidator        // 验证器
  
  // 元数据
  metadata: {
    version: string
    author: string
    tags: string[]
    [key: string]: any
  }
}
```

### 3.2 注册机制

#### 静态注册
**时机**：应用启动时
**方式**：在代码中直接注册
**用途**：注册内置节点类型

**流程**：
1. 导入节点定义
2. 调用注册函数
3. 验证定义完整性
4. 添加到注册表

#### 动态注册
**时机**：运行时
**方式**：通过API注册
**用途**：注册自定义节点类型

**流程**：
1. 提供节点定义
2. 验证定义格式
3. 加载组件和执行器
4. 注册到注册表
5. 更新UI

#### 插件注册
**时机**：插件加载时
**方式**：通过插件系统
**用途**：通过插件扩展节点

**流程**：
1. 插件定义节点
2. 插件加载时注册
3. 支持插件卸载

### 3.3 节点查找机制

#### 查找策略
1. **类型查找**：根据节点类型ID查找
2. **分类查找**：根据分类查找节点列表
3. **标签查找**：根据标签查找节点
4. **搜索查找**：根据关键词搜索

#### 查找优化
- **缓存机制**：缓存查找结果
- **索引机制**：建立查找索引
- **懒加载**：按需加载节点定义

---

## 节点配置系统

### 4.1 配置Schema设计

#### Schema结构
```
NodeConfigSchema {
  type: 'object'
  properties: {
    [key: string]: {
      type: string              // 字段类型
      title: string             // 显示标题
      description?: string      // 描述
      default?: any             // 默认值
      enum?: any[]              // 枚举值
      format?: string            // 格式（如：email, url）
      minimum?: number           // 最小值
      maximum?: number           // 最大值
      pattern?: string           // 正则表达式
      required?: boolean         // 是否必填
      ui?: {                     // UI配置
        component?: string       // 组件类型
        placeholder?: string     // 占位符
        options?: any[]          // 选项列表
        dependencies?: {         // 依赖关系
          [key: string]: any
        }
      }
    }
  }
  required?: string[]            // 必填字段列表
}
```

### 4.2 配置UI生成

#### 动态表单生成
根据Schema自动生成表单：
- **字符串类型** → 文本输入框
- **数字类型** → 数字输入框或滑块
- **布尔类型** → 开关
- **枚举类型** → 下拉选择或单选
- **对象类型** → 嵌套表单
- **数组类型** → 列表编辑器

#### 自定义组件
支持注册自定义配置组件：
- **文件上传组件**
- **代码编辑器组件**
- **颜色选择器组件**
- **日期时间选择器组件**

### 4.3 配置验证

#### 验证规则
1. **类型验证**：检查数据类型
2. **格式验证**：检查数据格式
3. **范围验证**：检查数值范围
4. **必填验证**：检查必填字段
5. **自定义验证**：业务逻辑验证

#### 验证时机
- **实时验证**：输入时即时验证
- **失焦验证**：失去焦点时验证
- **提交验证**：保存时完整验证

#### 验证反馈
- **错误提示**：显示错误信息
- **警告提示**：显示警告信息
- **成功提示**：显示成功信息

### 4.4 配置持久化

#### 存储方式
1. **节点数据中**：存储在节点的data.config中
2. **独立存储**：存储在独立的配置存储中
3. **版本化存储**：支持配置版本管理

#### 配置同步
- **实时同步**：配置变更立即保存
- **批量同步**：批量保存配置
- **冲突处理**：处理配置冲突

---

## 节点执行系统

### 5.1 执行器接口设计

#### 执行器接口
```
INodeExecutor {
  // 执行节点
  execute(
    node: Node,
    context: ExecutionContext
  ): Promise<NodeResult>
  
  // 验证节点
  validate(
    node: Node,
    context: ExecutionContext
  ): ValidationResult
  
  // 获取必需输入
  getRequiredInputs(node: Node): string[]
  
  // 获取输出定义
  getOutputs(node: Node): OutputDefinition[]
}
```

#### 执行上下文
```
ExecutionContext {
  workflowId: string
  executionId: string
  nodeId: string
  
  // 输入数据
  inputs: Record<string, any>
  
  // 全局变量
  globalVariables: Record<string, any>
  
  // 上游节点结果
  previousResults: Record<string, any>
  
  // 执行状态
  state: ExecutionState
  
  // 工具函数
  utils: ExecutionUtils
}
```

### 5.2 执行器实现模式

#### 模式一：同步执行器
**特点**：立即返回结果
**适用**：简单计算、数据转换
**实现**：直接返回结果

#### 模式二：异步执行器
**特点**：返回Promise
**适用**：API调用、文件操作
**实现**：返回Promise

#### 模式三：流式执行器
**特点**：支持数据流处理
**适用**：大数据处理、实时数据
**实现**：使用Stream API

#### 模式四：条件执行器
**特点**：根据条件分支执行
**适用**：条件判断、分支逻辑
**实现**：根据条件选择执行路径

### 5.3 执行流程

#### 执行阶段
1. **准备阶段**
   - 验证节点配置
   - 准备输入数据
   - 初始化执行上下文

2. **执行阶段**
   - 调用执行器
   - 处理执行结果
   - 更新执行状态

3. **完成阶段**
   - 处理输出数据
   - 更新下游节点
   - 记录执行日志

#### 错误处理
- **捕获错误**：捕获执行异常
- **错误分类**：区分错误类型
- **错误恢复**：尝试错误恢复
- **错误报告**：记录错误信息

### 5.4 执行状态管理

#### 状态定义
```
ExecutionState {
  status: 'pending' | 'running' | 'success' | 'error' | 'skipped'
  startTime?: Date
  endTime?: Date
  duration?: number
  error?: Error
  progress?: number
  message?: string
}
```

#### 状态流转
```
pending → running → success
              ↓
            error
              ↓
          skipped
```

#### 状态可视化
- **图标**：不同状态显示不同图标
- **颜色**：不同状态使用不同颜色
- **动画**：执行中显示动画
- **进度条**：显示执行进度

---

## 节点扩展机制

### 6.1 扩展方式

#### 方式一：代码扩展
**特点**：直接修改代码
**适用**：内置节点、核心节点
**优势**：性能好、类型安全
**劣势**：需要重新编译

#### 方式二：配置扩展
**特点**：通过配置文件定义
**适用**：简单节点、配置驱动节点
**优势**：灵活、无需编译
**劣势**：功能受限

#### 方式三：插件扩展
**特点**：通过插件系统加载
**适用**：第三方节点、动态节点
**优势**：完全解耦、可动态加载
**劣势**：需要插件系统支持

### 6.2 扩展开发流程

#### 步骤一：定义节点元数据
- 确定节点类型ID
- 定义节点基本信息
- 定义连接规则
- 定义配置Schema

#### 步骤二：实现UI组件
- 创建Vue组件
- 实现节点渲染
- 实现用户交互
- 实现状态显示

#### 步骤三：实现执行器
- 实现执行逻辑
- 实现数据验证
- 实现错误处理
- 实现日志记录

#### 步骤四：注册节点
- 创建节点定义
- 注册到注册表
- 测试节点功能
- 编写文档

### 6.3 扩展最佳实践

#### 组件开发
- **保持简洁**：组件职责单一
- **可配置**：通过props控制行为
- **可扩展**：预留扩展点
- **可测试**：易于单元测试

#### 执行器开发
- **幂等性**：支持重复执行
- **错误处理**：完善的错误处理
- **日志记录**：详细的日志记录
- **性能优化**：注意性能优化

#### 配置Schema设计
- **清晰明确**：字段定义清晰
- **完整验证**：完整的验证规则
- **用户友好**：友好的UI提示
- **向后兼容**：考虑版本兼容

### 6.4 节点分类体系

#### 分类原则
- **功能分类**：按功能划分
- **层级分类**：支持多级分类
- **标签分类**：支持标签分类
- **动态分类**：支持动态分类

#### 分类结构
```
节点类型
├── 控制流节点
│   ├── 开始节点
│   ├── 结束节点
│   ├── 条件节点
│   └── 循环节点
├── 业务节点
│   ├── 场景节点
│   │   ├── 大场景节点
│   │   └── 小场景节点
│   └── 引导节点
│       ├── 入戏引导
│       └── 出戏引导
├── 数据处理节点
│   ├── 变量节点
│   ├── 数据转换节点
│   └── 数据验证节点
└── 集成节点
    ├── API节点
    ├── 数据库节点
    └── 消息队列节点
```

---

## 实施建议

### 阶段一：基础重构（优先级：高）
1. 建立节点分层架构
2. 创建基础节点组件
3. 实现节点注册表
4. 重构现有节点

### 阶段二：复用机制（优先级：高）
1. 实现基础组件复用
2. 实现配置驱动渲染
3. 实现工厂模式创建
4. 优化节点样式系统

### 阶段三：配置系统（优先级：中）
1. 设计配置Schema
2. 实现动态表单生成
3. 实现配置验证
4. 实现配置持久化

### 阶段四：执行系统（优先级：中）
1. 设计执行器接口
2. 实现基础执行器
3. 实现执行流程
4. 实现状态管理

### 阶段五：扩展机制（优先级：低）
1. 实现插件系统
2. 提供扩展API
3. 编写扩展文档
4. 提供扩展示例

---

## 关键设计决策

### 决策1：组件复用策略
**选择**：组合模式 + 配置驱动
**理由**：平衡灵活性和可维护性

### 决策2：节点注册方式
**选择**：静态注册 + 动态注册
**理由**：支持内置节点和扩展节点

### 决策3：配置系统设计
**选择**：JSON Schema + 动态表单
**理由**：标准化和灵活性兼顾

### 决策4：执行器设计
**选择**：接口 + 多种实现模式
**理由**：支持不同执行场景

---

*最后更新：2024年*

